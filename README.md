队伍名：咸鱼打挺
队员： 支涛， 唐裕亮， 武林璐
此代码为决赛时使用的代码，其中包括了车辆调度C++代码以及车牌识别Python代码。车辆调度融合了判题器，并采取了应对死锁的相应手段；车牌识别代码线上评测精度能够达到98%。

## 程序思路
1. 发车策略
对于发车，我们并没有搞什么骚操作，设立了一个发车的队列长度$QueueLength$,同时定义了一个地图的面积量：
$$Area = \sum_i^n RoadLength \times nChannel$$
因此，队列长度就定义为：
$$QueueLength = Area \times \xi$$
其中的$\xi$，就是一个超参数，取多大需要我们自己把控。在初赛和复赛时，能够拿到地图，因此对于这个$\xi$我们能够取一个很好的值，但对于决赛，后面不给出地图，因此只能我们靠经验给出了，由于我们后面采取了相应的应对死锁的手段，还是能够保证得到一个有效answer。在复赛的时候，我们根据最后一辆优先车辆上路，最后一批预置车辆上路设立了三阶段不同的$\xi$,并根据路况信息的反馈上下浮动队列长度，决赛我们舍弃了这种复杂的思想，直接针对预置车辆设立了最后一辆不可调度的预置车辆前后两个阶段，每个阶段的$\xi$固定，不在上下浮动，初始设立两个阶段的$\xi$为`0.14`,`0.17`。

2. 车辆调度
车辆调度我们采用模拟车辆运行的方式，之前写的一个采用判题器运行的方式并没有这种方式效果好。寻路算法采用了`Dijkstra`算法，根据优先级，先调度优先级高的，然后调度普通车辆。所谓的模拟车辆运行，我们采用了一个粗略的车辆通过一段路的运行时间$forwardTime$:
$$forwardTime = \frac{RoadLength}{min(carSpeed, roadSpeed)}$$
每一个时间片减1,当该值小于0时，该车路口等待寻路，所以我们的模型是动态寻路过程，每辆车到每个路口都会根据路口信息寻路，对于有向图的权重我们设立了一个基础权重和车辆密度权重，具体的权重利用在`search_path`函数中。同时我们考虑到了托尾问题(最后没有车辆能够加入到道路了)，在托尾阶段，我们重新更换了权重，使寻路时更加偏重道路最短的路径，而不是车辆密度小的路径。
另外，对于自由调度的预置车辆选择问题，我们选取了最后出发的5%的预置车辆重新选路，5%的预置车辆更换出发时间，这个策略起到了很好的提升作用。

3. 死锁应对
应对死锁，我们将自己写的C++判题器程序融合进去，跑完我们的调度器之后，然后就进入判题程序，如果检测到死锁，那么更改两个阶段的$\xi$，重新调度。
4. 车牌识别 
车牌识别魔改了ResNet34网络，在第四个Block之后增加9个分支，对应的车牌中的9个字符，每个分支都是由两层全链接层构成。期间，本想利用数据合成程序来生成车牌数据扩充数据集，通过训练发现效果不佳，可能合成的数据分布和官方的不太一致。因此，并没有做过多的数据增强的操作。最终得到了98%左右的预测精度。
